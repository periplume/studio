#!/usr/bin/env bash
# file: resume
# desc: resume builder and publishing agent
# source: https://github.com/periplume/studio.git
# author: jason@bloom.us

_defaultPublishURL=jkl.bloom.us

###########################
# PREREQUISITES
###########################

# required commands
_requiredCommands=(git fzf make aws pandoc batcat)

# recommended commands
_recommendedCommands=(git-sizer tig)


###########################
# LIBRARY SOURCES
###########################

source studio-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

_fLOG
# the log/console functions instantited now will be re-initialized after all the
# command line parameters are processed, ie modified by flags
# defaults (from the studio-lib.sh file) will be used initially, which can be
# overriden below in BEHAVIOR

###########################
# ENVIRONMENT SETTINGS
###########################

# GLOBAL VARIABLES
# these never change in the context of a session
# these will be exported (in the case of fzf previews etc) 

# WORKING ENVIRONMENT
# _studioDirName is the umbrella or master namespace in which resume operates
_studioDirName=studio
# resume lives inside studio
_resumeDirName=resume

# NAMESPACE
# /_state/_key
_stateList="intent draft published sent"

# BEHAVIOR

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=false


####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF

usage: resume [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

alternate env settings:
 -a <name>  set the resume dir name to <name>
 -w <name>  set the master studio dir to <name> (assumes \$HOME/<name>)

EOF
}

_printCommands () {
	cat << EOF

commands:
 new                 create or edit a resume (or cover letter)
 import              import an external document
 delete              remove a resume (from the working space)
 rename              rename a resume
 publish             publish resume to ${_defaultPublishURL}
 list                browse documents
 inspect             run tig on the repo

EOF
}

_printInfo () {
  cat << EOF

resume manages all aspects of creating and maintaining a resume,
including publishing it to a designated URL

EOF
}


####################################
# PARAMETER PROCESSING FUNCTIONS
####################################

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	# make the original environment available to _shell for calling back into main
	export _originalParameters=${*}
	_debug "${FUNCNAME[0]}: positional parameters read: $*"
	while getopts ":hsdlva:w:" flag ; do
		_debug "${FUNCNAME[0]}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; _printCommands; exit 0
				;;
     a)
        export _resumeDirName=$OPTARG
        # TODO find a better way of avoiding using key words as OPTARGs
        [[ $OPTARG =~ add|edit|create|print ]] && { _error "'$OPTARG' not allowed as name for -$flag"; exit 1; }
        _debug "using alternative resume name '$_resumeDirName'"
        ;;
      w)
        export _studioDirName=$OPTARG
        [[ $OPTARG =~ add|edit|create|print ]] && { _error "'$OPTARG' not allowed as name for -$flag"; exit 1; }
        _debug "using alternative studio name '$_studioDirName'"
        ;;

 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      export _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				export _DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				export _LOG=true
				;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_debug "${FUNCNAME[0]}: _LOG=${_LOG}"
	_debug "${FUNCNAME[0]}: _SILENT=${_SILENT}"
	_debug "${FUNCNAME[0]}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_debug "${FUNCNAME[0]}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			new)
				_debug "${FUNCNAME[0]}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			import)
				_debug "${FUNCNAME[0]}: '$1' called, checking for $1 flags"
				_subCommand=$1
				return
				;;
			list)
				_debug "${FUNCNAME[0]}: '$1' called"
				_subCommand=$1
				return
				;;
			publish)
				_subCommand=$1
				return
				;;
			delete)
				_subCommand=$1
				return
				;;
			rename)
				_subCommand=$1
				return
				;;
			inspect)
				_subCommand=$1
				return
				;;
			create)
				_subCommand=$1
				return
				;;
			test)
				_subCommand=$1
				return
				;;
			*)
				_error "'${1}' is not a valid command"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
	# set (and print) the environment
	#_info "setting up environment now"
	# get the name etc
	self=$(basename "$0")
	self_call="$0"
	self_absolute=$(readlink -f "$0")
	self_pwd=$(pwd)
	export _studioDir="$(dirname ~/.)/${_studioDirName}"
	export _resumeDir="${_studioDir}/${_resumeDirName}"
	export _resumeGitDisk="${_resumeDir}/.git"
	export _logFile="${_resumeDir}/resume.log"
	export _git="--git-dir=${_resumeGitDisk}"
	export _gitWT="--git-dir=${_resumeGitDisk} --work-tree=${_resumeDir}"
	###cd "${_resumeDir}" || { _error "can not enter resume"; return 1; }
	# TODO need to fix this bullshit
	[[ -f "${_logFile}" ]] && _canLog=true || _canLog=false
	export _canLog
	_debug "self=$self"
	_debug "self_call=$self_call"
	_debug "self_absolute=$self_absolute"
	_debug "self_pwd=$self_pwd"
	_debug "_studioDirName=$_studioDirName"
	_debug "_studioDir=$_studioDir"
	_debug "_resumeDirName=$_resumeDirName"
	_debug "_resumeDir=$_resumeDir"
	_debug "_resumeGitDisk=$_resumeGitDisk"
	_debug "_logFile=$_logFile"
	_debug "_gitWT=$_gitWT"
	_debug "_git=$_git"
	_debug "git version= $(git $_git -v)"
	_debug "_canLog=${_canLog:-false}"
	_debug "_user=${_user:-unset}"
	_debug "_DEBUG=$_DEBUG"
	_debug "_SILENT=$_SILENT"
	_debug "_LOG=$_LOG"
	_debug "git command: 'git ${_git}'"
	_debug "gitWT command: 'git ${_gitWT}'"
}

_isEnvSufficient() {
	# check for required tools, report accordingly
	# TODO add recommended checks with _missing{0:name,1:name}
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME[0]}: ${_required} not found"
			_sufficient=false
		else
			_debug "${FUNCNAME[0]}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}
	
_doesDirExist() {
	# check if the specified DIR ($_resumeDir) exists
	# check if it is a resume-created git
	# return 1 if missing or not git
	# mind condition: if subcommand is create
	if [[ ${_subCommand:=} = "create" ]]; then
		if [ -d ${_resumeDir} ]; then
			_warn "${_resumeDir} already exists; cannot create"
			_subCommand=null
			return 1
		fi
	elif [ -d ${_resumeDir} ]; then
		if [ -f ${_resumeGitDisk}/description ]; then
			# the git description file exists, lets check it for our marker
			read -r _desc<${_resumeGitDisk}/description
			if [[ ${_desc} = "${_studioDirName}:${_resumeDirName}" ]]; then
				# if repo does exist, return 0
				_debug "${_resumeGitDisk}/description = ${_desc}"
			else
				# if repo does not exist, warn and exit
				_error "${_resumeDir} exists and is NOT a studio-created repo"
				return 1
			fi
		else
			_error "${_resumeDir} exists and is NOT a git repo"
			_error "move existing ${_resumeDir} before proceeding"
			return 1
		fi
	else
		# dir does not exist
		_warn "${_resumeDir} does not exist"
		read -rsn1 -p "$(_ask 'create resume repo now? [y/n]')" _yn
		echo
		[[ ${_yn} != "y" ]] && { _warn "'resume create' must be executed first"; return 1;  }
		_create || { _error "could not create resume repo"; return 1; }
		return
	fi
}

#################################
# SUBCOMMAND OPTION PROCESSING
#################################

# this is a placeholder function which shows how to process add flags
_getAddOpts() {
	# check for _add() flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_debug "${FUNCNAME[0]}: positional parameters read: $*"
	shift
	while getopts ":d:" flag "$@"; do
		case ${flag} in
			d)
				# specify alternate date (rather than today)
				_debug "alternate date specified=$OPTARG"
				_altDate="${OPTARG}"
				;;
			?)
				 _error "${FUNCNAME[0]}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}


####################################
# HEALTH AND STATUS
####################################

_inspect() {
	tig -C${_resumeDir}
}

_isIndexClean() {
	git ${_git} diff-index --quiet --cached main 2>&1 >/dev/null || return 1
}

_isBufferClean() {
	# checks for files left in intent/ (ie vim swp)
	[[ -z "$(ls ${_resumeDir}/intent)" ]]
}

# layers to check for consistency
# vim auto-save files (needs vimrc to be integrated)
# ls /intent/.*.swp for vim swap files
# ls -I ".*.swp" /intent/ for files saved in intent but not comitted
# git index with diff-index

# SPEC
# new                 create a new resume or cover letter
# edit                edit an existing resume or cover letter
# delete              remove a resume (from the working space)
# import              import an external document
# publish             publish resume to ${_defaultPublishURL}
# list                browse documents
# inspect             run tig on the repo

# delete
# call picker to select
# confirm delete...remove
# commit

# import
# call external file picker
# select file
# call picker to select name
# starts in intent
# saved moves to draft
# commit

# publish
# call picker to select name
# convert to html
# push to url
# move key and html to published
# commit

##################################
# NEW, EDIT, and DERIVE
##################################

# TODO
# path isn't correct when run as cli (shell otoh uses cwd)

_validateName() {
	# test the validity of the name...strict naming enforced
	# because we expect to publish to a url for http, enforce naming here
	# allowed characters
	# a-z
	# 0-9
	# space and dash
	# here we allow space, when put to html we convert space to dash
	local _valid=true
	local _lengthMax=40
	# tests
	# cannot be empty
	test -z "${1}" && { _warn "empty name not allowed"; return 1; }
	# first and last char must be lower or digit
  [[ "${1}" =~ ^[[:digit:]|[:lower:]] ]] || \
    { _warn "name '${1}' must begin with a letter or digit"; _valid=false; }
  [[ "${1}" =~ [[:digit:]|[:lower:]]$ ]] || \
    { _warn "name '${1}' must end with a letter or digit"; _valid=false; }
	# no repeating spaces
  [[ ! "${1}" =~ ([ ]){2} ]] || \
    { _warn "space character mustn't repeat"; _valid=false; }
	# length limit
	[[ "${#1}" -le ${_lengthMax} ]] || \
    { _warn "length (${#1}) exceeds length limit of ${_lenLimit}"; _valid=false; }
	# lower, number, dash and spaces only
	[[ "${1}" =~ ^([[:lower:]]|[[:digit:]]|[- ])*$ ]] || \
		{ _warn "lower case, digits, dash and space characters only"; _valid=false; }
	[[ $_valid = true ]] || return 1
}

_new() {
	# run _picker to select the name
	local _name				# name of the document to make or modify
	local _state			# the subdirectory (or state) of _name
	local _seed				# the source file for a DERIVE operation
	local _newkey			# the new name for a DERIVE operation
	local _path				# the full path to the file to be edited
	_name=$(_picker "choose existing or new")
	[[ -z ${_name} ]] && { _warn "no name selected"; return; }
	_debug "got name from _picker: '${_name}'"
	_validateName "${_name}" || { _error "name not allowed"; return 1; }
	#
  # DETERMINE OPERATION (NEW, EDIT, OR DERIVE)
  #
  if _doesKeyExist "${_name}"; then
    # EDIT OR DERIVE
    _state=$(_getKeyState "${_name}")
    _info "'${_name}' exists in ${_state}"
    read -rsn1 -p "$(_ask 'press "e" to edit, "n" to create a new derivative, q to abort')" _en
    echo
    if [[ ${_en} = "q" ]]; then
      _warn "aborting operation"; return
    elif [[ ${_en} = "e" ]]; then
      _debug "edit existing"
    elif [[ ${_en} = "n" ]]; then
      _debug "edit derivative"
      _seed="${_resumeDir}/${_state}/${_name}"
      _state=intent
      _newkey=$(_picker "choose a NEW name")
			_validateName "${_newkey}" || { _error "name not allowed"; return 1; }
      [[ ${_newkey} = ${_name} ]] && { _warn "cannot use same name as original '${_name}'"; return; }
      _doesKeyExist "${_newkey}" && { _warn "name exists, cannot use existing name"; return; }
      _name=${_newkey}
    fi
  else
    # NEW
    _debug "'${_name}' is new"
    _state=intent
  fi
  _path="${_resumeDir}/${_state}/${_name}"
  _info "name: '${_name}'"
  _info "state: '${_state}'"
  _info "path: '${_path}'"
  _info "seed: '${_seed:-}'"
	# make these available to other functions
	export _name
	export _state
	export _path
	export _seed
	#
  # SEED FILE (WHEN NECESSARY) AND EDIT
  #
  # need to seed the buffer if _seed is not empty
  if [[ ! -z ${_seed:-} ]]; then
    # seed the file into intent
    _seedFile "${_seed}" "${_path}"
  fi
	#
	# EDIT FILE
	#
	_edit
	[[ ! -f "${_path}" ]] && { _warn "no file found at '${_path}'"; return; }
	# depending on the return, either git commit or not
	_checkChanges || { _warn "no changes detected"; return; }
	_gitCommit || { _warn "git commit failed"; return; }
}

_gitCommit() {
	# relies on _name, _state
  local _pathspec="${_state}/${_name}"
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" add "${_pathspec}"
  [[ $? != 0 ]] && { _warn "git add ${_pathspec} failed"; return 1; }
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -q -m "saved ${_name} as ${_state}"
  [[ $? != 0 ]] && { _warn "git commit failed"; return 1; }
	return 0
}

_gitAdd() {
	# relies on _name, _state
  local _pathspec="${_state}/${_name}"
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" add "${_pathspec}"
  [[ $? != 0 ]] && { _warn "git add ${_pathspec} failed"; return 1; }
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -q -m "saved ${_name} as ${_state}"
  [[ $? != 0 ]] && { _warn "git commit failed"; return 1; }
	return 0
}

_gitDelete() {
	# relies on _name, _state
  local _pathspec="${_state}/${_name}"
	rm "${_resumeDir}/${_state}/${_name}"
  [[ $? != 0 ]] && { _warn "deletion of ${_name} failed"; return 1; }
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" rm --quiet "${_pathspec}" 
  [[ $? != 0 ]] && { _warn "git rm of ${_pathspec} failed"; return 1; }
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -q -m "deleted ${_name} from ${_state}"
  [[ $? != 0 ]] && { _warn "git commit failed"; return 1; }
	return 0
}

_gitRename() {
	# relies on _oldName, _newName, _state
  local _oldPathspec="${_state}/${_oldName}"
  local _newPathspec="${_state}/${_newName}"
	#mv "${_resumeDir}/${_state}/${_oldName}" "${_resumeDir}/${_state}/${_newName}"
  #[[ $? != 0 ]] && { _warn "mv of '${_oldName}' to '${_newName}' failed"; return 1; }
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" mv "${_oldPathspec}" "${_newPathspec}"
  [[ $? != 0 ]] && { _warn "git mv of ${_oldPathspec} to ${_newPathspec} failed"; return 1; }
  git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -q -m "renamed ${_oldName} to ${_newName}"
  [[ $? != 0 ]] && { _warn "git commit failed"; return 1; }
	return 0
}


_checkChanges() {
	# determine the operation and check if changes were made
	# relies on _seed, _path, _name
	# if no changes were made, return 1
	# if changes were made, return 0
	# CHANGE _key to _name
	if [[ ! -z ${_seed:-} ]]; then
    _info "operation: DERIVE"
    # _seed is not empty because we are doing a DERIVE operation
    # compare _path with _seed to determine if changes were made
    if cmp -s "${_seed}" "${_path}"; then
      _warn "'${_path}' is unchanged"
      rm "${_path}"
      return 1
    else
      _info "'${_path}' has changed"
    fi
  elif [[ -z ${_seed:-} && ${_state} = "intent" ]]; then
    _info "operation: NEW"
		[[ ! -e "${_path}" ]] && { _warn "'${_path}' not found"; return 1; }
    local _draft="${_resumeDir}/draft/${_name}"
    _info "moving ${_path} to ${_draft}"
    mv "${_path}" "${_draft}"
    _state=draft
  else
    _info "operation: EDIT"
    # _seed is empty because we are doing an EDIT operation
    # compare _path with git to determine if changes were made if EDIT
    _info "seed is '${_seed:-}' empty"
    _info "path is '${_path}'"
    _info "state is '${_state}'"
    git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" diff --quiet "${_state}/${_name}"
    _gitDiff=$?
    _info "git diff returns '${_gitDiff}'"
    [[ $_gitDiff = 0 ]] && { _warn "'${_state}/${_name}' is unchanged"; return 1; }
    [[ $_gitDiff != 0 ]] && { _warn "'${_state}/${_name}' is changed"; }
  fi
  _info "state=${_state}"
  _info "path=${_path}"
  _info "seed=${_seed:-}"
  _info "name=${_name}"
}

_picker() {
	# used for name selection WITHIN repo (namespace control)
	# optional arg 1 = instructions (put into fzf header}
	local _scope			# the starting point for the search
	local _dirList		# the list of subdirectories to search within
	local _query			# the query string used in fzf
	local _selection	# the selected string
	local _name				# the name returned
	export _guide="${1:-select a name}"
	# maintain state
	export _tmp="/tmp/studio.picker"
	[[ -d ${_tmp} ]] || mkdir ${_tmp}
	# help function
	_showHelp() {
		printf '
-- name selector --

press "/" to close this help screen
ESC to abort
TAB to fill the query with the selected value
ENTER to accept the choice
ENTER without a query term will use the selected value
ENTER with a query term will use the query term'
	}
	export -f _showHelp
	# preview the files
	_preview() {
		echo "viewing $1"
		batcat -l md --style=plain --color always "$1"
	}
	export -f _preview
	# populate the prompt string
	_prompt() {
		echo " > " 
	}
	export -f _prompt
	# populate the header string
	_header() {
		echo "${_guide} (? for help, ESC to exit)"
	}
	export -f _header
	# get the main list
	_getView() {
		find ${_stateList} -type f -not -path "*/.*" -not -path "*.log"
	}
	export -f _getView
	# the main function
	_fzfWrapper() {
		local _query			# the query string typed
		local _selection	# the selected item
		local _lines			# number of lines fzf returned
		trap "rm -rf ${_tmp}" EXIT
		while true; do
			_fzfReturn=$(fzf \
				--no-mouse \
				--no-multi \
				--ansi \
				--delimiter="/" \
				--with-nth=3 \
				--print-query \
				--header 'Press ? for help, ESC to exit' \
				--info=inline \
				--preview='_preview {-2..}' \
				--preview-window '60%,border-sharp' \
				--bind "start:reload(_getView)+transform-prompt(_prompt)" \
				--bind "start:+transform-header(_header)" \
				--bind "tab:replace-query+first" \
				--bind "?:change-preview(_showHelp)" \
				--bind "/:change-preview(_preview {})" \
			);
			# if user aborted, break out of the loop
			[[ ! ${_fzfReturn} ]] && break
			# now look at what is returned
			_lines=$(echo "${_fzfReturn}" | wc -l)
			_query=$(echo "${_fzfReturn}" | head -n1)
			_selection=$(echo "${_fzfReturn}" | tail -n1)
			# strip everything but name
			_selection=${_selection##*/}
			# look for a query name without selection (new name without any match)
			[[ ${_lines} == 1 ]] && { echo ${_query}; break; }
			# multi-line return evaluation
			# if query is empty then we only have selection
			[[ -z ${_query} ]] && { echo ${_selection}; break; }
			# if query and selection are the same, easy
			[[ ${_query} == ${_selection} ]] && { echo ${_query}; break; } 
			# if query and selection are not the same...use query
			[[ ${_query} != ${_selection} ]] && { echo ${_query}; break; }
			# the above creates the minor annoyance that one must use TAB to populate
			# the query...acceptable because i don't know how else to determine
		done
	}
	# run the main function
	_fzfWrapper
}

_edit() {
	# given path ($1), edit file, otherwise edit $_path
	local _file=${1:-${_path}}
	#vim -c 'set syntax=markdown' "${1}"
	#nano --syntax=markdown "${1}"
	nano --syntax=markdown "${_file}"
}

_seedFile() {
	# given a path for the source ($1)
	# and a name for the new ($2)
	# seed the new file with the source
	# return 0 if success, 1 if failed
	_debug "seeding from ${1}"
	[[ -e "${2}" ]] && { _warn "'${2}' exists, cannot clobber"; return 1; }
	cat "${1}" > "${2}"
	[[ $? = 0 ]] && return
	return 1
}

_doesKeyExist() {
	# check if the key exists anywhere
	# arg 1 = key
	# return 0 if key exists
	# return 1 if key does not exist
	for i in ${_stateList[@]}; do
		test -f "${_resumeDir}/$i/$1" && return 0
	done
	return 1
}

_getKeyState() {
	# return the key state
	# arg 1 = key
	local _state
	for i in ${_stateList[@]}; do
		if test -f "${_resumeDir}/$i/$1"; then
			_state=$i
		fi
	done
	echo ${_state}
}

_fzfPicker() {
	# attempt to normalize the _picker answer
	# arg 1 = bottom line of header for specific instructions (optional)
	local _instructions=${1:-undefined}
	local _fzfResult
	local _answer
	# modify header 
	_header=$'tab: fill with selected  enter: accept \nctrl-b|d|p|s|a to view intent|draft|published|sent|all \n'
	[[ ! -z ${_instructions} ]] && _header=${_header}instructions:${_instructions}
	_fzfResult=$(find ${_stateList} -type f | fzf \
		--no-multi --no-mouse --print-query \
		--prompt 'searching all> ' \
		--info=inline \
		--header "$_header" \
		--delimiter='/' --with-nth=2 \
		--color 'bg:#111111,preview-bg:#222222,prompt:yellow' \
		--bind 'tab:replace-query+first' \
		--bind 'ctrl-a:change-prompt(searching all> )+reload(find intent draft published sent -type f)' \
		--bind 'ctrl-b:change-prompt(searching intent> )+reload(find intent -type f)' \
		--bind 'ctrl-d:change-prompt(searching draft> )+reload(find draft -type f)' \
		--bind 'ctrl-p:change-prompt(searching published> )+reload(find published -type f)' \
		--bind 'ctrl-s:change-prompt(searching sent> )+reload(find sent -type f)' \
		--preview-window 'up,70%,wrap' \
		--preview 'batcat -l md --color always {}')
	query=$(echo "${_fzfResult}" | head -n1)
	selection=$(echo "${_fzfResult}" | tail -n1)
	#_info "query is '${query}'"
	#_info "selection is '${selection}'"
	# if query is empty...use selected
	[[ -z "${query}" ]] && { echo "${selection}"; return; }
	# otherwise return the query
	echo "${query}"
	return
	_info "fzf '${_fzfResult}'"
	_lines=$(echo ${_fzfResult} | wc -l)
	_warn ${_fzfResult}:${_lines}
	echo ${_fzfResult}
}
	#	--bind 'enter:print-query' \

############################
# IMPORT
############################

_import() {
	# calls _finder to identify file for import
	local _importedFile
	local _path
	local _name
	local _state
	_importedFile=$(_finder)
	[[ -f "${_importedFile}" ]] || { _warn "'${_importedFile}' is not a file"; return; } 
	_debug "imported file is ${_importedFile}"
	_name=$(_picker "choose a new name")
	_doesKeyExist "${_name}" && { _warn "'${_name}' already exists, new name required"; return; }
	[[ -d "${_name}" ]] && { _warn "'${_name}' is a directory silly, no can do"; return; }
	[[ -z "${_name}" ]] && { _warn "'${_name}' is empty...not allowed"; return; }
	_debug "name chosen is ${_name}"
	export _path="${_resumeDir}/intent/${_name}"
  _seedFile "${_importedFile}" "${_path}"
	_edit
	mv "${_resumeDir}/intent/${_name}" "${_resumeDir}/draft/${_name}"
	export _state=draft
	_gitCommit || { _warn "git commit failed"; return; }
}

_finder() {
	# single file finder and selector
	# uses fzf as the interface to find and select a file to import
	# uses files in /tmp to maintain state
	# state includes the CWD of the fzf subshell...thus we can maneuver
	# returns the full path of the following variable (or 1 if none was selected)
	local _selectedFile
	# set the temp file dir
	export _tmpDir="/tmp/studio.finder"
	[[ -d ${_tmpDir} ]] || mkdir ${_tmpDir}
	# help for _preview
	_showHelp() {
			printf '
+------------------------------------------------+
| studio finder help  |  hit "/" to close help   |
+---------------------+--------------------------+

options

toggle hidden files and directories
LEFT PANE: view files, directories, or both
PREVIEW PANE: cycle preview for dirs
 tree -L 1
 tree -L 2
 tree -L 3
 tree
 ls
 ls -l

arrows
up/down             right/left
lines
lines
ctrl-c: exit
ctrl-a: toggle between "find ~" and "find /" (functional reset)
ctrl-f: toggle between find dirs and find dirs+files
ctrl-f: toggle between ignore hidden and include hidden' 
	}
	export -f _showHelp
	# toggle option (simply touches or removes file of name given in arg 1)
	_toggle() {
		# pass the option name to the function
		_opt=${1:-}
		if [ -f ${_tmpDir}/${1} ]; then
			rm -f ${_tmpDir}/${1} >/dev/null 2>&1
		else
			touch ${_tmpDir}/${1}
		fi
	}
	export -f _toggle
	_set() {
		# set an option
		# arg 1 = option name
		# arg 2 = option value
		echo "${2}" > "${_tmpDir}/${1}"
	}
	export -f _set
	_get() {
		# get value for option
		[[ -f "${_tmpDir}/${1}" ]] || { echo err; return; }
		cat "${_tmpDir}/${1}"
	}
	export -f _get
	# populate fzf with a view (ie a list)
	_getView() {
		# populate the left pane with find results
		# arg 1 (optional) sets the PATH for find
		# other options are toggled in fzf and read in file
		#
		#local _findScope="find ~"
		local _findScope
		local _findDepth="-maxdepth 1"
		local _findType="-type d"
		local _findHide='-not -path "*/.*"'
		local _cwd		# current working directory (stored in /tmp)
		local _scope	# ctrl-a (toggle) between / and ~ changes view context and resets search
		local _path		# the find search path
		# first set the find search path (find where?)
		# read the _cwd from tmp (this means we are in an active session)
		[[ -f "${_tmpDir}/cwd" ]] && _cwd=$(cat "${_tmpDir}/cwd")
		#
		# set the find search path
		# if no arg, finder is starting or reloading
		if [[ -z ${1:-} ]]; then
			# no arg passed
			# check $_cwd
			if [ -z "$_cwd" ]; then
				# _cwd is not set, this is an initial view
				_path="$HOME"
			else
				# _cwd is set and no arg...scope change
				[ -f "${_tmpDir}/root" ] && _path="/"
				[ ! -f "${_tmpDir}/root" ] && _path="$HOME"
			fi
		else
			# arg passed
			if [ -f "${1}" ]; then
				# the selection is a file
				touch "${_tmpDir}/_getView.expandfile"
			elif [ -d "${1}" ] && [[ "${1}" = "${_cwd}" ]]; then
				# $1 is the same as $_cwd and is a directory
				# then it is a reload (or left arrow on a subdir)
				_path="${1}"
				touch "${_tmpDir}/_getView.reload"
			else
				# $1 is a directory and not _cwd
				# it is a change context view
				# set find scope
				_path="${1}"
				touch "${_tmpDir}/_getView.cd"
				#
			fi
		fi
		# set the find search path now
		_findScope="find '${_path}'"
		# update the state file for _cwd
		echo "${_path}" > "${_tmpDir}/cwd"
		# set the search depth (for deep vs surface search)
		# toggle the dirs or dirs+files option
		[ -f "${_tmpDir}/files" -a ! -f "{$_tmpDir}/nodirs" ] && _findType=""
		# toggle hidden files (default: ignore hidden)
		[ -f "${_tmpDir}/hidden" ] && _findHide=""
		# print find command to tmp file for debugging
		echo ${_findScope} ${_findDepth} ${_findType} ${_findHide} > "${_tmpDir}/_getView.find"
		# assemble find command
		eval ${_findScope} ${_findDepth} ${_findType} ${_findHide}
	}
	export -f _getView
	_preview() {
		# preview window of _finder produced by fzf
		# context: file or dir (or help)
		# default: tree -C
		# options: hidden files or dirs
		# 					files, dirs, or both
		# 
		local _viewMeans="echo"
		local _viewFiles		# on or off
		local _viewDirs			# on or off
		if [[ -d "${1}" ]]; then
			# viewing a directory
			echo '$ tree -L 1 -C "$1"'
			_cwd=$(cat "${_tmpDir}/cwd")
			echo "cwd=${_cwd:-empty}"
			[[ -f "${_tmpDir}/nofiles" ]] 
			tree -L 1 -C "$1"
		else
			# viewing a file
			#less -C "$1"
			batcat --color always "${1}"
		fi
	}
	export -f _preview
	_prompt() {
		# set the prompt string
		# what is the scope
		[[ -f "${_tmpDir}/root" ]] && _scope=/ || _scope="~"
		# hidden or not
		[[ -f "${_tmpDir}/hidden" ]] && _hidden=hide || _hidden=nohide
		# files or no files
		[[ -f "${_tmpDir}/files" ]] && _files=files || _files=nofiles
		echo "$_scope $_hidden $_files > "
	}
	export -f _prompt
	# main fzf wrapper
	_fzfWrapper() {
		# trap exit and clean up state (_tmpDir) every time
		trap "rm -rf ${_tmpDir}" EXIT
		# loop until fzf returns the selection
		while true; do
			_fzfReturn=$(fzf \
				--no-multi \
				--no-mouse \
				--ansi \
				--print-query \
				--delimiter=/ \
				--track \
				--header='Press ? for help' \
				--info=inline \
				--preview='_preview {}' \
				--preview-window '65%,border-sharp' \
				--prompt '> ' \
				--bind "ctrl-c:abort" \
				--bind "ctrl-a:execute(_toggle root)+reload(_getView)+first" \
				--bind "ctrl-a:+transform-prompt(_prompt)" \
				--bind "ctrl-e:execute(_toggle nodirs)+reload(_getView {})+first" \
				--bind "ctrl-f:execute(_toggle files)+reload(_getView {})+first" \
				--bind "ctrl-f:+transform-prompt(_prompt)" \
				--bind "ctrl-h:execute(_toggle hidden)+reload(_getView {})+first" \
				--bind "ctrl-h:+transform-prompt(_prompt)" \
				--bind "start:reload(_getView)" \
				--bind "change:last" \
				--bind "enter:accept-non-empty" \
				--bind "?:change-preview(_showHelp | less)" \
				--bind "/:change-preview(_preview {})" \
				--bind "ctrl-o:execute(xmessage {..-2})" \
				--bind "ctrl-l:execute(xmessage {q} {})" \
				--bind "right:reload(_getView {})+first" \
				--bind "left:reload(_getView {..-2})+first"
			);
		[[ ! ${_fzfReturn} ]] && break
		query=$(echo "${_fzfReturn}" | head -n1)
		selection=$(echo "${_fzfReturn}" | tail -n1)
		echo "${selection}" && break
	done
	}
	_fzfWrapper
}

############################
# PUBLISH
############################

_publish () {
	_name=${1:-jkl-resume}
	_mdFile="${_resumeDir}/draft/${_name}"
	[[ -e "${_mdFile}" ]] || { _warn "no file '${_mdFile}'"; return; }
	pandoc "${_mdFile}" -f markdown -t html -V title:"" -s -o "/tmp/${_name}.html"
	export AWS_PAGER=""
	aws s3api put-object --bucket jkl.bloom.us --key jkl-resume.html --content-type text/html --body "/tmp/${_name}.html"
	[[ $? == 0 ]] && _info "success" || _warn "failed to upload"
}


############################
# DELETE
############################

_delete() {
	local _nameToDelete
	local _state
	local _path
	_nameToDelete=$(_picker "choose what to delete")
	_doesKeyExist "${_nameToDelete}" || { _warn "'${_nameToDelete}' does not exist"; return; }
  read -rsn1 -p "$(_ask "press ${boldred}d${reset} to confirm deletion of '${_nameToDelete}'")" _confirm
	echo
	[[ ${_confirm} = "d" ]] || { _warn "aborted delete of '${_nameToDelete}'"; return; }
	export _name=${_nameToDelete}
	export _state=$(_getKeyState "${_nameToDelete}")
	_gitDelete || _error "_gitDelete for ${_name} failed"
}

############################
# RENAME
############################

_rename() {
	local _oldName
	local _newName
	local _state
	local _commonPath
	_oldName=$(_picker "choose name to rename")
	_doesKeyExist "${_oldName}" || { _warn "'${_oldName}' does not exist"; return; }
	_newName=$(_picker "choose new name")
	_doesKeyExist "${_newName}" && { _warn "'${_newName}' is not unique"; return; }
  read -rsn1 -p "$(_ask "press ${boldred}y${reset} to rename '${_oldName}' to '${_newName}'")" _confirm
	echo
	[[ ${_confirm} = "y" ]] || { _warn "aborted rename of '${_oldName}'"; return; }
	export _oldName
	export _newName
	export _state=$(_getKeyState "${_oldName}")
	_gitRename || _error "_gitRename for ${_oldName} failed"
}

############################
# CREATE
############################

_create() {
	# create a new resume database
	local _gitUserName=$(git config --global --get user.name)
  local _gitUserEmail=$(git config --global --get user.email)
	local _resumeDisk=${_resumeGitDisk}
  trap _irishExit SIGINT
	_ask "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z "${_studioName}" ] || _studioDirName="${_studioName}"
	_ask "enter resume name ["${_resumeDirName}"] "
	read _resumeName
	[ -z ${_resumeName} ] || _resumeDirName="${_resumeName}"
 _ask "enter preferred username [${_gitUserName}] "
  read _userName
  [ -z ${_userName} ] && _userName="${_gitUserName}"
  _ask "enter preferred email [${_gitUserEmail}] "
  read _userEmail
  [ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_setEnv
	_info "studio dir name: ${_studioDirName}"
	_info "studio path: ${_studioDir}"
	_info "resume path: ${_resumeDir}"
	_info "resume gitdisk: ${_resumeGitDisk}"
	_info "resume user name: ${_userName}"
	_info "resume user email: ${_userEmail}"
	read -rsn1 -p "$(_ask 'proceed? (y/n)')" _yn
	echo
	[[ "$_yn" != "y" ]] && { _warn "explicit 'y' required; aborting"; return 1; }
	[ ! -d "${_resumeDir}" ] && mkdir -p "${_resumeDir}"
	git init -q -b main "${_resumeDir}"
	git config --global includeif.gitdir:"${_resumeGitDisk}".path "${_resumeGitDisk}/.gitconfig"
	git config --file="${_resumeGitDisk}"/.gitconfig user.name "${_userName}"
	git config --file="${_resumeGitDisk}"/.gitconfig user.email "${_userEmail}"
	touch ${_logFile}
	echo "resume.log" > "${_resumeDir}/.gitignore"
	echo "${_studioDirName}:resume" > ${_resumeGitDisk}/description
	git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" add .gitignore
	git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -m "[genesis] created by ${_userName}"
	mkdir "${_resumeDir}/draft"
	mkdir "${_resumeDir}/sent"
	mkdir "${_resumeDir}/published"
	mkdir "${_resumeDir}/intent"
}

###############
###### SHELL
###############

_shell() {
	# enter (cd) into resume environment
	# change the command history file
	# change the prompt dynamically
	### this is a chicken egg problem...want to put this in _setEnv, but need to allow for the first start
	cd "${_resumeDir}" || { _error "can not enter resume"; return 1; }
	HISTFILE="${_studioDir}/.resume_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	local _p				# prompt function for shell only
	local _dirty
	#
	# set up local variables to reflect state
	#
	#_init() {
	# init function; check how things were left last and act accordingly
	#
	# call:
	# integrity function (focus on this app and its namespace)
	# check the /intent...any cleanup necessary?
	# check the git index
	# check for dangling anything
	#
	# call:
	# redundancy function (focus beyond the local files)
	# check the status of data protection (dsink media and backups)
	# check the status of remote mirrors (gitdisk)
	#
	# confirm exit function; what to check and cleanup on exit
	_confirmExit() {
		if _isIndexClean; then
			exit
		else
			_debug "index is dirty"
			_ask "save session? press ${label}y${reset} to commit changes, ${label}n${reset} to discard changes"
			while read -r -s -n 1  __confirm; do
				echo # needed for newline after _ask
				case ${__confirm} in
					y)
						git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -m "[${self}] $(date) closed"
						exit
						;;
					n)
						exit
						;;
					*)
						_mainPrompt
						;;
				esac
			done
		fi
	}
	# print welcome function
	_displayWelcome() {
	cat <<HEREDOC
                                            
 *RESUME*

resume: type ${green}help${reset} for guidance
        type ${red}stop${reset} to leave

HEREDOC
	}
	# print usage
	_printShellUsage() {
		_printCommands
	}
	# main shell prompt function
	_mainPrompt() {
	#
	# ignore ctrl+\ ctrl+z and ctrl+c
	trap '' SIGQUIT SIGTSTP SIGINT SIGTERM
	# call the init() function to check integrity
	# init()
	# set the prompt
	_p() {
		# colors cannot derive from tput here...as 'read -e' becomes confused
		reset=$'\001\e[0m\002'
		red=$'\001\e[00;31m\002'
		yellow=$'\001\e[00;33m\002'
		green=$'\001\e[00;32m\002'
		_cH=$'\001\e[00;45m\002'		# white text, magenta bg
		_cG=$'\001\e[00;7m\002'			# black text, while bg
		_cU=$'\001\e[00;32m\002'		# green text, black bg
		_cS=$'\001\e[00;33m\002'		# yellow text, black bg
		_cB=$'\001\e[00;44m\002'		# white text, blue bg
		# check the git index and intent buffer; set indicators accordingly
		_index="${green}o${reset}"
		_isIndexClean || _index="${red}x${reset}"
		_buffer="${green}+${reset}"
		_isBufferClean || _buffer="${red}-${reset}"
		_headRev=$(git ${_git} rev-parse --short HEAD)
		_u=$(git ${_git} config --get user.name)
		echo -n "${_cH}${_studioDirName}${reset}:${_cB}${_resumeDirName}${reset} ${_cU}${_u}${reset} [${_cS}${_headRev}${reset}] ${_buffer}${_index} > "
	}
	local __input
	while IFS='' read -r -d $'\n' -p "$(_p)" -e __input || true; do
		history -s "${__input}"
		if [[ -z "${__input}" ]]; then
			true
		elif [[ ${__input} =~ [[:cntrl:]] ]]; then
			_warn "control char found"
		elif [[ ${__input} == $'\e' ]]; then
			_warn "no escape" && true
		elif [[ "${__input}" =~ (^stop$|^quit$|^exit$|^q$) ]]; then
			_confirmExit
		elif [[ "${__input}" =~ (^help$|^h$|^\?$) ]]; then
			_printShellUsage
		elif [[ "${__input}" =~ (^list$|^l$) ]]; then
			_picker "browsing only" || true
		elif [[ "${__input}" =~ (^import$) ]]; then
			_import
		elif [[ "${__input}" =~ (^pub$) ]]; then
			_publish
		elif [[ "${__input}" =~ (^print$|^p$) ]]; then
			_print
		elif [[ "${__input}" =~ (^i$) ]]; then
			_inspect
		elif [[ "${__input}" =~ ^git ]]; then
			# pass git commands back through epistle script
			_gitCommand=(${__input})
			git ${_gitWT} ${_gitCommand[@]:1} || :
		elif [[ "${__input}" =~ (^new$|^n$) ]]; then
			# TODO this little bit is a problem and has caused me grief
			# when invoked as './resume' the eval below uses the resume in the path
			# which makes developing rather difficult, i think, and introduces
			# terrible potential problems
			# need to know how exactly the script has been called if we want to run
			# the same script within this little "shell"
			#eval "${self}" "${_originalParameters}" new || true
			eval "${self_absolute}" "${_originalParameters}" new || true
			# always use the original script that was executed!
		elif [[ "${__input}" =~ (^edit$|^e$) ]]; then
			eval "${self}" "${_originalParameters}" new || true
		else
			eval "${self}" "${_originalParameters}" "${__input}" || :
		fi
	done
	}
	_displayWelcome
	_mainPrompt
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_debug "${FUNCNAME[0]}: parameters read: ${*}"
	_debug "${FUNCNAME[0]}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
	_debug "${FUNCNAME[0]}: _subCommand: ${_subCommand:-}"
	_debug "${FUNCNAME[0]}: remaining args: $_workingParams"
	# setup the environment after processing all command line parameters
	_setEnv
	# reinitialize log functions after processing all command line options
	_fLOG
	_user=$(git ${_git} config --get user.name)
	# validate the environment
	# TODO figure out a better means of knowing
	# 1. is this an interactive shell session
	# 2. is this part of a pipe
	# 3. are we in our custom interactive shell (and does that matter?)
	# set up logging and stdout stderr etc with traps
	# possibly check for tty?
	[[ -t 1 ]] && _debug 'STDOUT is attached to TTY'
	[[ -t 0 ]] || _debug 'STDIN is attached to pipe'
	[[ -p /dev/stdout ]] && _debug 'STDOUT is attached to a pipe'
	[[ ! -t 1 && ! -p /dev/stdout ]] && _debug 'STDOUT is attached to a redirection'
	_isEnvSufficient || { _error "cannot run until these problems are resolved"; return 1; }
	_doesDirExist || { _warn "repo must be created before use"; return;  }
	# run germ shell if no arguments
	[ -z "${_subCommand:-}" ] && _shell
	# ctrl-d exits out of the last command...the trap set in the _shell catches
	# the EXIT signal, and runs.  but by now, we're toast.  ctrl-d must be caught
	# earlier in order to be able to pass the commands back to the master script.
	# it's a handy trick but may be unnecessary
	# otherwise, pass the commands to the called "command"
	_debug "now calling the eval to run '${_subCommand:-}'"
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}" || exit
}
# don't run if sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "${@}"
	if [ $? -gt 0 ]; then
		exit 1
	fi
fi
