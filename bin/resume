#!/usr/bin/env bash
# file: resume
# desc: resume builder and publishing agent
# source: https://github.com/periplume/studio.git
# author: jason@bloom.us

_defaultPublishURL=jkl.bloom.us

###########################
# PREREQUISITES
###########################

# required commands
_requiredCommands=(git fzf make)

# recommended commands
_recommendedCommands=(git-sizer tig)


###########################
# LIBRARY SOURCES
###########################

source studio-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

_fLOG
# the log/console functions instantited now will be re-initialized after all the
# command line parameters are processed, ie modified by flags
# defaults (from the studio-lib.sh file) will be used initially, which can be
# overriden below in BEHAVIOR

###########################
# ENVIRONMENT SETTINGS
###########################

# GLOBAL VARIABLES
# these never change in the context of a session
# these will be exported (in the case of fzf previews etc) 

# WORKING ENVIRONMENT
# _studioDirName is the umbrella or master namespace in which resume operates
_studioDirName=studio
# resume lives inside studio
_resumeDirName=resume
# get the name of the script itself
self=$(basename $0)

# NAMESPACE
# /_state/_key
_stateList="intent draft published sent"

# BEHAVIOR

# debugging and logging settings
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=false


####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF

usage: resume [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit

alternate env settings:
 -a <name>  set the resume dir name to <name>
 -w <name>  set the master studio dir to <name> (assumes \$HOME/<name>)

EOF
}

_printCommands () {
	cat << EOF

commands:
 new                 create a new resume or cover letter
 edit                edit an existing resume or cover letter
 delete              remove a resume (from the working space)
 import              import an external document
 publish             publish resume to ${_defaultPublishURL}
 list                browse documents
 inspect             run tig on the repo

EOF
}

_printInfo () {
  cat << EOF

resume manages all aspects of creating and maintaining a resume,
including publishing it to a designated URL

EOF
}

####################################
# PARAMETER PROCESSING FUNCTIONS
####################################

_getOpts () {
	# check for global command flags and set VARS accordingly
	local OPTIND
	# make the original environment available to _shell for calling back into main
	export _originalParameters=${*}
	_debug "${FUNCNAME}: positional parameters read: $*"
	while getopts ":hsdlva:w:" flag ; do
		_debug "${FUNCNAME}: OPTIND=$OPTIND flag=$flag"
		case ${flag} in 
			h)
				_printInfo ; _printUsage; exit 0
				;;
     a)
        export _resumeDirName=$OPTARG
        # TODO find a better way of avoiding using key words as OPTARGs
        [[ $OPTARG =~ add|edit|create|print ]] && { _error "'$OPTARG' not allowed as name for -$flag"; exit 1; }
        _debug "using alternative resume name '$_resumeDirName'"
        ;;
      w)
        export _studioDirName=$OPTARG
        [[ $OPTARG =~ add|edit|create|print ]] && { _error "'$OPTARG' not allowed as name for -$flag"; exit 1; }
        _debug "using alternative studio name '$_studioDirName'"
        ;;

 	    s)
				_debug "${FUNCNAME}: enabling silent mode with flag -$flag"
 	      export _SILENT=true
				;;
			d)
				_debug "${FUNCNAME}: enabled debug mode with flag -$flag"
				export _DEBUG=true
				;;
			l)
				_debug "${FUNCNAME}: enabled log mode with flag -$flag"
				export _LOG=true
				;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	# export a paired down parameter string flags and args read within this
	# function will be discarded, leaving behind only that which the rest needs
	export _workingParams=$*
	_debug "${FUNCNAME}: _LOG=${_LOG}"
	_debug "${FUNCNAME}: _SILENT=${_SILENT}"
	_debug "${FUNCNAME}: _DEBUG=${_DEBUG}"
	return
}

_getSubcommand() {
	# look for the first subcommand and set _subCommand accordingly
	while ((${#})); do
		_debug "${FUNCNAME}: reading parameter '${1}'"
		case $1 in
			help)
				_printInfo ; _printUsage; exit 0
				;;
			new)
				_debug "${FUNCNAME}: '$1' called, checking for $1 flags now"
				_subCommand=$1
				_getAddOpts
				return
				;;
			edit)
				_debug "${FUNCNAME}: '$1' called, checking for $1 flags"
				_subCommand=$1
				return
				;;
			list)
				_debug "${FUNCNAME}: '$1' called"
				_subCommand=$1
				return
				;;
			publish)
				_subCommand=$1
				return
				;;
			inspect)
				_subCommand=$1
				return
				;;
			create)
				_subCommand=$1
				return
				;;
			test)
				_subCommand=$1
				return
				;;
			*)
				#_error "${FUNCNAME}: '${1}' is not a subcommand"
				_error "'${1}' is not a valid command"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
	# set (and print) the environment
	#_info "setting up environment now"
	export _studioDir="$(dirname ~/.)/${_studioDirName}"
	export _resumeDir="${_studioDir}/${_resumeDirName}"
	export _resumeGitDisk="${_resumeDir}/.git"
	export _logFile="${_resumeDir}/resume.log"
	export _git="--git-dir=${_resumeGitDisk}"
	export _gitWT="--git-dir=${_resumeGitDisk} --work-tree=${_resumeDir}"
	[[ -f "${_logFile}" ]] && _canLog=true || _canLog=false
	export _canLog
	_debug "self=$self"
	_debug "_studioDirName=$_studioDirName"
	_debug "_studioDir=$_studioDir"
	_debug "_resumeDirName=$_resumeDirName"
	_debug "_resumeDir=$_resumeDir"
	_debug "_resumeGitDisk=$_resumeGitDisk"
	_debug "_logFile=$_logFile"
	_debug "_gitWT=$_gitWT"
	_debug "_git=$_git"
	_debug "git version= $(git $_git -v)"
	_debug "_canLog=${_canLog:-false}"
	_debug "_user=${_user:-unset}"
	_debug "_DEBUG=$_DEBUG"
	_debug "_SILENT=$_SILENT"
	_debug "_LOG=$_LOG"
	_debug "git command: 'git ${_git}'"
	_debug "gitWT command: 'git ${_gitWT}'"
}

_isEnvSufficient() {
	# check for required tools, report accordingly
	# TODO add recommended checks with _missing{0:name,1:name}
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}
	
_doesDirExist() {
	# check if the specified DIR ($_resumeDir) exists
	# check if it is a resume-created git
	# return 1 if missing or not git
	# mind condition: if subcommand is create
	if [[ ${_subCommand:=} = "create" ]]; then
		if [ -d ${_resumeDir} ]; then
			_warn "${_resumeDir} already exists; cannot create"
			_subCommand=null
			return 1
		fi
	elif [ -d ${_resumeDir} ]; then
		if [ -f ${_resumeGitDisk}/description ]; then
			# the git description file exists, lets check it for our marker
			read -r _desc<${_resumeGitDisk}/description
			if [[ ${_desc} = "${_studioDirName}:${_resumeDirName}" ]]; then
				# if repo does exist, return 0
				_debug "${_resumeGitDisk}/description = ${_desc}"
			else
				# if repo does not exist, warn and exit
				_error "${_resumeDir} exists and is NOT a studio-created repo"
				return 1
			fi
		else
			_error "${_resumeDir} exists and is NOT a git repo"
			_error "move existing ${_resumeDir} before proceeding"
			return 1
		fi
	else
		# dir does not exist
		_warn "${_resumeDir} does not exist"
		read -rsn1 -p "$(_ask 'create resume repo now? [y/n]')" _yn
		echo
		[[ ${_yn} != "y" ]] && { _warn "'resume create' must be executed first"; return 1;  }
		_create || { _error "could not create resume repo"; return 1; }
		return
	fi
}

#################################
# SUBCOMMAND OPTION PROCESSING
#################################

_getAddOpts() {
	# check for _add() flags and args
	local OPTIND=1
	set -- ${_workingParams}
	_debug "${FUNCNAME}: positional parameters read: $*"
	shift
	while getopts ":d:" flag "$@"; do
		case ${flag} in
			d)
				# specify alternate date (rather than today)
				_debug "alternate date specified=$OPTARG"
				_altDate="${OPTARG}"
				;;
			?)
				 _error "${FUNCNAME}: unknown flag -$OPTARG"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	export _workingParams=$*
}


####################################
# HEALTH AND STATUS
####################################

_inspect() {
	tig -C${_resumeDir}
}

_isIndexClean() {
	# radical departure here...use intent/ as pre-commit working
	# directory...make vim auto-save files there...etc
	git ${_git} diff-index --quiet --cached main 2>&1 >/dev/null || return 1
}

_isBufferClean() {
	# checks for files left in intent/ (ie vim swp)
	[[ -z "$(ls ${_resumeDir}/intent)" ]]
}

# _report()
# print a human (or machine) readable health report

# layers to check for consistency
# vim auto-save files (needs vimrc to be integrated)
# ls /intent/.*.swp for vim swap files
# ls -I ".*.swp" /intent/ for files saved in intent but not comitted
# git index with diff-index

# SPEC
# new                 create a new resume or cover letter
# edit                edit an existing resume or cover letter
# delete              remove a resume (from the working space)
# import              import an external document
# publish             publish resume to ${_defaultPublishURL}
# list                browse documents
# inspect             run tig on the repo

# new
# without args...
# call picker to select name
# existing name triggers choice
#  edit existing or derive from selected
# new name or derived name starts in intent
# saved moves to draft
# commit

# edit
# maybe can remove this...function is in new

# delete
# call picker to select
# confirm delete...remove
# commit

# import
# call external file picker
# select file
# call picker to select name
# starts in intent
# saved moves to draft
# commit

# publish
# call picker to select name
# convert to html
# push to url
# move key and html to published
# commit

# list
# call picker to browse all

##################################
# NEW, EDIT, and DERIVE
##################################

# options
# create a brand new resume (from scratch)
# create a new resume (new name) derived from an existing one
# edit an existing one

# new flow
# picker
# if name is new, start from scratch
# if name exists, _ask
#   edit existing
#   derive new from existing

# editor vim swap files
# to force swp into /intent
# add the following to .vimrc
# set directory^=${_resumeDir}/intent

# TODO
# path isn't correct when run as cli (shell otoh uses cwd)

_new() {
	# create a new document
	# select an existing to edit or derive
	# or choose a new name to start from scratch
	#local _user=${_user:=jkl}
	local _role="resume"
	local _key
	local _newkey
	local _seed
	local _state=intent
	#_key=$(_picker "specify the name")
	_key=$(_picker)
	_info "fzf exit status is $?"
	_info "got key from fzf: '${_key}'"
	# check the key name (coming back from fzf...unreliable)	
	if [[ ${_key} == *"/"* ]]; then
		# key is in state/key format
		_info "${_key} found to include state"
		_newkey=${_key#*/}
		_state=${_key%/*}
		_key=${_newkey}
	else
		_info "${_key} found to be solo"
		# key is in key-only format (without state)
		# should validate name here
		:
	fi
	_info "key is ${_key}"
	_info "state is ${_state}"
	test -z ${_key} && { _warn "empty name not allowed"; return; }
	if _doesKeyExist ${_key}; then
		_state=$(_getKeyState ${_key})
		_warn "${_key} exists in ${_state}"
		read -rsn1 -p "$(_ask 'e for edit, n for new derivative')" _en
		echo
		if [[ ${_en} = "e" ]]; then
			_info "edit existing"
		elif [[ ${_en} = "n" ]]; then
			# would be nice to pass new header to _picker
			_seed=${_resumeDir}/${_state}/${_key}
			_info "seed is ${_seed}"
			_state=intent
			_newkey=$(_picker choose-new)
			# check the key name (coming back from fzf...depends)	
			if [[ ${_newkey} == *"/"* ]]; then
				# key is in state/key format
				_newkey=${_newkey#*/}
			else
				# key is in key-only format (without state)
				:
			fi
			_info "new name is ${_newkey}"
			test -z ${_newkey} && { _warn "empty name not allowed"; return; }
			[[ ${_newkey} = ${_key} ]] && { _warn "cannot use same name as original '${_key}'"; return; }
			_key=${_newkey}
			_info "key is ${_key}"
		else
			#_warn "no such command"
			return
		fi
	else
		_info "${_key} is new"
		_state=intent
	fi
	_path="${_resumeDir}/${_state}/${_key}"
	_info path:${_path}
	_info seed:${_seed:-}
	# need to seed the buffer if _seed is not empty
	if [[ ! -z ${_seed:-} ]]; then
		# seed the file into intent
		_info "seeding ${_path} from ${_seed}"
		cat ${_seed} > ${_path}
		vim "+normal G$" "${_path}"
		# compare the files...if same, then what?
		# abort, or ask?
		if cmp -s ${_seed} ${_path}; then
			_info "${_path} is unchanged (derived from ${_seed}"
			return
		else
			_info "${_path} is different than ${_seed}"
		fi
	else
		# start something from scratch
		vim "+normal G$" "${_path}"
	fi
	# need to allow abort...if vim does not save changes
	local _draft="${_resumeDir}/draft/${_key}"
	local _pathspec="draft/${_key}"
	_info "moving ${_path} to ${_draft}"
	mv "${_path}" "${_draft}"
	git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" add "${_pathspec}"
	[[ $? != 0 ]] && _warn "git add ${_pathspec} failed" || _info "git add success"
	git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -q -m "saved draft of ${_key}"
	[[ $? != 0 ]] && _warn "git commit failed" || _info "git commit success"
}

_doesKeyExist() {
	# check if the key exists anywhere
	# arg 1 = key
	# return 0 if key exists
	# return 1 if key does not exist
	for i in ${_stateList[@]}; do
		test -f ${_resumeDir}/$i/$1 && return 0
	done
	return 1
}

_getKeyState() {
	# return the key state
	# arg 1 = key
	local _state
	for i in ${_stateList[@]}; do
		if test -f ${_resumeDir}/$i/$1; then
			_state=$i
		fi
	done
	echo ${_state}
}

_picker() {
	# arg 1 optional: fzf header (instructions)
	local _header="${1:-shift-tab: fill query with selected line\nctrl-i|d|p|s|a to view intent|draft|published|sent|all\n}"
	#local _header="shift-tab: fill query with selected line\nctrl-i|d|p|s|a to view intent|draft|published|sent|all\n"
	find ${_stateList} -type f | fzf \
		--no-multi --no-mouse --print-query \
		--prompt "searching all> " \
		--header=$'tab: use selected\nctrl-b|d|p|s|a to view intent|draft|published|sent|all\n' \
		--color=bg:#111111,preview-bg:#222222,prompt:yellow \
		--bind 'tab:replace-query' \
		--bind 'enter:print-query' \
		--bind 'ctrl-a:change-prompt(searching all> )+reload(find intent draft published sent -type f)' \
		--bind 'ctrl-b:change-prompt(searching intent> )+reload(find intent -type f)' \
		--bind 'ctrl-d:change-prompt(searching draft> )+reload(find draft -type f)' \
		--bind 'ctrl-p:change-prompt(searching published> )+reload(find published -type f)' \
		--bind 'ctrl-s:change-prompt(searching sent> )+reload(find sent -type f)' \
		--preview-window=up,70%,wrap --preview='cat {}' 
}

############################
# CREATE
############################

_create() {
	# create a new resume database
	local _gitUserName=$(git config --global --get user.name)
  local _gitUserEmail=$(git config --global --get user.email)
	local _resumeDisk=${_resumeGitDisk}
  trap _irishExit SIGINT
	_ask "enter studio name ["${_studioDirName}"] "
	read _studioName
	[ -z "${_studioName}" ] || _studioDirName="${_studioName}"
	_ask "enter resume name ["${_resumeDirName}"] "
	read _resumeName
	[ -z ${_resumeName} ] || _resumeDirName="${_resumeName}"
 _ask "enter preferred username [${_gitUserName}] "
  read _userName
  [ -z ${_userName} ] && _userName="${_gitUserName}"
  _ask "enter preferred email [${_gitUserEmail}] "
  read _userEmail
  [ -z ${_userEmail} ] && _userEmail="${_gitUserEmail}"
	_setEnv
	_info "studio dir name: ${_studioDirName}"
	_info "studio path: ${_studioDir}"
	_info "resume path: ${_resumeDir}"
	_info "resume gitdisk: ${_resumeGitDisk}"
	_info "resume user name: ${_userName}"
	_info "resume user email: ${_userEmail}"
	read -rsn1 -p "$(_ask 'proceed? (y/n)')" _yn
	echo
	[[ "$_yn" != "y" ]] && { _warn "explicit 'y' required; aborting"; return 1; }
	[ ! -d "${_resumeDir}" ] && mkdir -p "${_resumeDir}"
	git init -q -b main "${_resumeDir}"
	git config --global includeif.gitdir:"${_resumeGitDisk}".path "${_resumeGitDisk}/.gitconfig"
	git config --file="${_resumeGitDisk}"/.gitconfig user.name "${_userName}"
	git config --file="${_resumeGitDisk}"/.gitconfig user.email "${_userEmail}"
	touch ${_logFile}
	echo "resume.log" > "${_resumeDir}/.gitignore"
	echo "${_studioDirName}:resume" > ${_resumeGitDisk}/description
	git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" add .gitignore
	git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -m "[genesis] created by ${_userName}"
	mkdir "${_resumeDir}/draft"
	mkdir "${_resumeDir}/sent"
	mkdir "${_resumeDir}/published"
	mkdir "${_resumeDir}/intent"
}

###############
###### SHELL
###############

_shell() {
	# enter (cd) into resume environment
	# change the command history file
	# change the prompt dynamically
	cd "${_resumeDir}" || { _error "can not enter resume"; return 1; }
	HISTFILE="${_studioDir}/.resume_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	local _p				# prompt function for shell only
	local _dirty
	#
	# set up local variables to reflect state
	#
	#_init() {
	# init function; check how things were left last and act accordingly
	#
	# call:
	# integrity function (focus on this app and its namespace)
	# check the /intent...any cleanup necessary?
	# check the git index
	# check for dangling anything
	#
	# call:
	# redundancy function (focus beyond the local files)
	# check the status of data protection (dsink media and backups)
	# check the status of remote mirrors (gitdisk)
	#
	# confirm exit function; what to check and cleanup on exit
	_confirmExit() {
		if _isIndexClean; then
			exit
		else
			_debug "index is dirty"
			_ask "save session? press ${label}y${reset} to commit changes, ${label}n${reset} to discard changes"
			while read -r -s -n 1  __confirm; do
				echo # needed for newline after _ask
				case ${__confirm} in
					y)
						git -C "${_resumeDir}" --git-dir="${_resumeGitDisk}" commit -m "[${self}] $(date) closed"
						exit
						;;
					n)
						exit
						;;
					*)
						_mainPrompt
						;;
				esac
			done
		fi
	}
	# print welcome function
	_displayWelcome() {
	cat <<HEREDOC
                                            
 *RESUME*

resume: type ${green}help${reset} for guidance
        type ${red}stop${reset} to leave

HEREDOC
	}
	# print usage
	_printShellUsage() {
		_printCommands
	}
	# main shell prompt function
	_mainPrompt() {
	#
	# ignore ctrl+\ ctrl+z and ctrl+c
	trap '' SIGQUIT SIGTSTP SIGINT SIGTERM
	# call the init() function to check integrity
	# init()
	# set the prompt
	_p() {
		# colors cannot derive from tput here...as 'read -e' becomes confused
		reset=$'\001\e[0m\002'
		red=$'\001\e[00;31m\002'
		yellow=$'\001\e[00;33m\002'
		green=$'\001\e[00;32m\002'
		_cH=$'\001\e[00;45m\002'		# white text, magenta bg
		_cG=$'\001\e[00;7m\002'			# black text, while bg
		_cU=$'\001\e[00;32m\002'		# green text, black bg
		_cS=$'\001\e[00;33m\002'		# yellow text, black bg
		_cB=$'\001\e[00;44m\002'		# white text, blue bg
		# check the git index and intent buffer; set indicators accordingly
		_index="${green}o${reset}"
		_isIndexClean || _index="${red}x${reset}"
		_buffer="${green}+${reset}"
		_isBufferClean || _buffer="${red}-${reset}"
		_headRev=$(git ${_git} rev-parse --short HEAD)
		_u=$(git ${_git} config --get user.name)
		echo -n "${_cH}${_studioDirName}${reset}:${_cB}${_resumeDirName}${reset} ${_cU}${_u}${reset} [${_cS}${_headRev}${reset}] ${_buffer}${_index} > "
	}
	local __input
	while IFS='' read -r -d $'\n' -p "$(_p)" -e __input || true; do
		history -s "${__input}"
		if [[ -z "${__input}" ]]; then
			true
		elif [[ ${__input} =~ [[:cntrl:]] ]]; then
			_warn "control char found"
		elif [[ ${__input} == $'\e' ]]; then
			_warn "no escape" && true
		elif [[ "${__input}" =~ (^stop$|^quit$|^exit$|^q$) ]]; then
			_confirmExit
		elif [[ "${__input}" =~ (^help$|^h$|^\?$) ]]; then
			_printShellUsage
		elif [[ "${__input}" =~ (^list$|^l$) ]]; then
			_picker || true
		elif [[ "${__input}" =~ (^print$|^p$) ]]; then
			_print
		elif [[ "${__input}" =~ ^git ]]; then
			# pass git commands back through epistle script
			_gitCommand=(${__input})
			git ${_gitWT} ${_gitCommand[@]:1} || :
		elif [[ "${__input}" =~ (^new$|^n$) ]]; then
			eval "${self}" "${_originalParameters}" new || true
		elif [[ "${__input}" =~ (^edit$|^e$) ]]; then
			eval "${self}" "${_originalParameters}" new || true
		else
			eval "${self}" "${_originalParameters}" "${__input}" || :
		fi
	done
	}
	_displayWelcome
	_mainPrompt
}

main() {
	# what are we trying to do (read all the positional parameters and set VARS)
	_getOpts "${@}"
	_debug "${FUNCNAME}: parameters read: ${*}"
	_debug "${FUNCNAME}: paired-down parameters: $_workingParams"
	_getSubcommand $_workingParams
	_debug "${FUNCNAME}: _subCommand: ${_subCommand:-}"
	_debug "${FUNCNAME}: remaining args: $_workingParams"
	# setup the environment after processing all command line parameters
	_setEnv
	# reinitialize log functions after processing all command line options
	_fLOG
	_user=$(git ${_git} config --get user.name)
	# validate the environment
	# TODO figure out a better means of knowing
	# 1. is this an interactive shell session
	# 2. is this part of a pipe
	# 3. are we in our custom interactive shell (and does that matter?)
	# set up logging and stdout stderr etc with traps
	# possibly check for tty?
	[[ -t 1 ]] && _debug 'STDOUT is attached to TTY'
	[[ -t 0 ]] || _debug 'STDIN is attached to pipe'
	[[ -p /dev/stdout ]] && _debug 'STDOUT is attached to a pipe'
	[[ ! -t 1 && ! -p /dev/stdout ]] && _debug 'STDOUT is attached to a redirection'
	_isEnvSufficient || { _error "cannot run until these problems are resolved"; return 1; }
	_doesDirExist || { _warn "repo must be created before use"; return;  }
	# run germ shell if no arguments
	[ -z "${_subCommand:-}" ] && _shell
	# ctrl-d exits out of the last command...the trap set in the _shell catches
	# the EXIT signal, and runs.  but by now, we're toast.  ctrl-d must be caught
	# earlier in order to be able to pass the commands back to the master script.
	# it's a handy trick but may be unnecessary
	# otherwise, pass the commands to the called "command"
	_debug "now calling the eval to run '${_subCommand:-}'"
	[ -n "${_subCommand:-}" ] && eval _"${_subCommand}" || exit
}
main "${@}"
